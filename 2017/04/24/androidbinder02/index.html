<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="简祖明">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Android binder机制二"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="jianjin33"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.comundefined"/>
  
    <link rel="alternate" href="/atom.xml" title="jianjin33" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>jianjin33</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Android binder机制二</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  首页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  文章
                  
                </a>
              </li>
            
              <li>
                <a href="http://www.jianshu.com/u/4079f82f6280">
                  
                  简书
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/jianjin33">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:jianjin33@gmail.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By 简祖明</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2017-04-24</span>
            <span class="time">18:57:46</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/技术/">技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Android/">#Android</a> <a class="tag" href="/tags/C/">#C++</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>binder机制<br><a id="more"></a><br>接上一篇文章<a href="https://jianjin33.github.io/2017/04/21/androidbinder01/" target="_blank" rel="external">binder机制一</a></p>
<h4 id="一、BpServiceManager是什么："><a href="#一、BpServiceManager是什么：" class="headerlink" title="一、BpServiceManager是什么："></a>一、BpServiceManager是什么：</h4><p>p是proxy即代理的意思，Bp就是BinderProxy，BpServiceManager，就是SM的Binder代理。既然是代理，那肯定希望对用户是透明的，那就是说头文件里边不会有这个Bp的定义。<br>果然，BpServiceManager就在刚才的IServiceManager.cpp中定义。<br>/frameworks/native/libs/binder/IServiceManager.cpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class BpServiceManager : public BpInterface&lt;IServiceManager&gt;</div><div class="line">//这种继承方式，表示同时继承BpInterface和IServiceManager，这样IServiceManger的addService必然在这个类中实现</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">//注意构造函数参数的命名 impl，难道这里使用了Bridge模式？真正完成操作的是impl对象？</div><div class="line">//这里传入的impl就是new BpBinder(0)</div><div class="line">    BpServiceManager(const sp&lt;IBinder&gt;&amp; impl)</div><div class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">     virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service)</div><div class="line">    &#123;</div><div class="line">       待会再说..</div><div class="line">&#125;</div><div class="line">基类BpInterface的构造函数（经过兑现后）</div><div class="line">//这里的参数又叫remote，唉，真是害人不浅啊。</div><div class="line">inline BpInterface&lt; IServiceManager &gt;::BpInterface(const sp&lt;IBinder&gt;&amp; remote)</div><div class="line">    : BpRefBase(remote)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line">BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp; o)</div><div class="line">    : mRemote(o.get()), mRefs(NULL), mState(0)</div><div class="line">//o.get()，这个是sp类的获取实际数据指针的一个方法，你只要知道</div><div class="line">//它返回的是sp&lt;xxxx&gt;中xxx* 指针就行</div><div class="line">&#123;</div><div class="line">//mRemote就是刚才的BpBinder(0)</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，到这里，我们知道了：<br>sp<iservicemanager> sm = defaultServiceManager(); 返回的实际是BpServiceManager，它的remote对象是BpBinder，传入的那个handle参数是0。<br>回到上一篇文章的起点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">    //上面的讲解已经完了</div><div class="line">    MediaPlayerService::instantiate();//实例化MediaPlayerservice</div><div class="line">    //看来这里有名堂！</div><div class="line"> </div><div class="line">    ProcessState::self()-&gt;startThreadPool();</div><div class="line">    IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">&#125;</div></pre></td></tr></table></figure></iservicemanager></p>
<h4 id="二、MediaPlayerService"><a href="#二、MediaPlayerService" class="headerlink" title="二、MediaPlayerService"></a>二、MediaPlayerService</h4><p>那下面我们看看后续又干了什么？以MediaPlayerService为例。<br>它位于/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">266 void MediaPlayerService::instantiate() &#123;</div><div class="line">267    defaultServiceManager()-&gt;addService(    //传进来服务的名字，穿件去new出来的对象</div><div class="line">268            String16(&quot;media.player&quot;), new MediaPlayerService());</div><div class="line">269&#125;</div><div class="line">270</div><div class="line">271MediaPlayerService::MediaPlayerService()</div><div class="line">272&#123;</div><div class="line">273    ALOGV(&quot;MediaPlayerService created&quot;);</div><div class="line">274    mNextConnId = 1;</div><div class="line">275</div><div class="line">276    mBatteryAudio.refCount = 0;</div><div class="line">277    for (int i = 0; i &lt; NUM_AUDIO_DEVICES; i++) &#123;</div><div class="line">278        mBatteryAudio.deviceOn[i] = 0;</div><div class="line">279        mBatteryAudio.lastTime[i] = 0;</div><div class="line">280        mBatteryAudio.totalTime[i] = 0;</div><div class="line">281    &#125;</div><div class="line">282    // speaker is on by default</div><div class="line">283    mBatteryAudio.deviceOn[SPEAKER] = 1;</div><div class="line">284    // defaultServiceManager返回的是刚才创建的BpServiceManager调用它的addService函数。</div><div class="line">285    // reset battery stats</div><div class="line">286    // if the mediaserver has crashed, battery stats could be left</div><div class="line">287    // in bad state, reset the state upon service start.</div><div class="line">288    BatteryNotifier::getInstance().noteResetVideo();</div><div class="line">290    MediaPlayerFactory::registerBuiltinFactories();</div><div class="line">291&#125;</div></pre></td></tr></table></figure></p>
<p>MediaPlayerService从BnMediaPlayerService派生<br>class MediaPlayerService : public BnMediaPlayerService</p>
<p>FT，MediaPlayerService从BnMediaPlayerService派生。<br>Bn 是Binder Native的含义，是和Bp相对的，Bp的p是proxy代理的意思，那么另一端一定有一个和代理打交道的东西，这个就是Bn。<br>讲到这里会有点乱喔。先分析下，到目前为止都构造出来了什么。<br>lBpServiceManager<br>lBnMediaPlayerService<br>这两个东西不是相对的两端，从BnXXX就可以判断，BpServiceManager对应的应该是BnServiceManager，BnMediaPlayerService对应的应该是BpMediaPlayerService。<br>我们现在在哪里?对了，我们现在是创建了BnMediaPlayerService，想把它加入到系统的中去。<br>我创建一个新的Service—BnMediaPlayerService，想把它告诉ServiceManager。<br>那我怎么和ServiceManager通讯呢？恩，利用BpServiceManager。所以嘛，我调用了BpServiceManager的addService函数！<br>为什么要搞个ServiceManager来呢？这个和Android机制有关系。所有Service都需要加入到ServiceManager来管理。同时也方便了Client来查询系统存在哪些Service，没看见我们传入了字符串吗？这样就可以通过Human Readable的字符串来查找Service了。</p>
<h4 id="三、addService"><a href="#三、addService" class="headerlink" title="三、addService"></a>三、addService</h4><p>addService是调用的BpServiceManager的函数。前面略去没讲，现在我们看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service)</div><div class="line">    &#123;</div><div class="line">        Parcel data, reply;</div><div class="line">        //data是发送到BnServiceManager的命令包</div><div class="line">        //看见没？先把Interface名字写进去，也就是什么android.os.IServiceManager</div><div class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</div><div class="line">        //再把新service的名字写进去 叫media.player</div><div class="line">        data.writeString16(name);</div><div class="line">        //把新服务service—&gt;就是MediaPlayerService写到命令中</div><div class="line">        data.writeStrongBinder(service);</div><div class="line">        //调用remote的transact函数</div><div class="line">        status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</div><div class="line">        return err == NO_ERROR ? reply.readInt32() : err;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我的天，remote()返回的是什么？<br>remote(){ return mRemote; }–&gt;啊？找不到对应的实际对象了？？？<br>还记得我们刚才初始化时候说的：<br>“这里的参数又叫remote，唉，真是害人不浅啊“<br>原来，这里的mRemote就是最初创建的BpBinder..<br>好吧，到那里去看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">BpBinder的位置在framework\native\libs\binder\BpBinder.cpp</div><div class="line">status_t BpBinder::transact(</div><div class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</div><div class="line">&#123;</div><div class="line">//又绕回去了，调用IPCThreadState的transact。</div><div class="line">//注意啊，这里的mHandle为0,code是ADD_SERVICE_TRANSACTION,data是命令包</div><div class="line">//reply是回复包，flags=0</div><div class="line">        status_t status = IPCThreadState::self()-&gt;transact(</div><div class="line">            mHandle, code, data, reply, flags);</div><div class="line">        if (status == DEAD_OBJECT) mAlive = 0;</div><div class="line">        return status;</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">再看看IPCThreadState的transact函数把</div><div class="line">status_t IPCThreadState::transact(int32_t handle,</div><div class="line">                                  uint32_t code, const Parcel&amp; data,</div><div class="line">                                  Parcel* reply, uint32_t flags)</div><div class="line">&#123;</div><div class="line">    status_t err = data.errorCheck();</div><div class="line"> </div><div class="line">    flags |= TF_ACCEPT_FDS;</div><div class="line">   </div><div class="line">    if (err == NO_ERROR) &#123;</div><div class="line">        //调用writeTransactionData 发送数据</div><div class="line">err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">      if ((flags &amp; TF_ONE_WAY) == 0) &#123;</div><div class="line">        if (reply) &#123;</div><div class="line">            err = waitForResponse(reply);</div><div class="line">        &#125; else &#123;</div><div class="line">            Parcel fakeReply;</div><div class="line">            err = waitForResponse(&amp;fakeReply);</div><div class="line">        &#125;</div><div class="line">      ....等回复</div><div class="line">        err = waitForResponse(NULL, NULL);</div><div class="line">   ....   </div><div class="line">    return err;</div><div class="line">&#125;</div><div class="line">再进一步，瞧瞧这个...</div><div class="line">status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,</div><div class="line">    int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)</div><div class="line">&#123;</div><div class="line">    binder_transaction_data tr;</div><div class="line"> </div><div class="line">    tr.target.handle = handle;</div><div class="line">    tr.code = code;</div><div class="line">    tr.flags = binderFlags;</div><div class="line">   </div><div class="line">    const status_t err = data.errorCheck();</div><div class="line">    if (err == NO_ERROR) &#123;</div><div class="line">        tr.data_size = data.ipcDataSize();</div><div class="line">        tr.data.ptr.buffer = data.ipcData();</div><div class="line">        tr.offsets_size = data.ipcObjectsCount()*sizeof(size_t);</div><div class="line">        tr.data.ptr.offsets = data.ipcObjects();</div><div class="line">    &#125;</div><div class="line">....</div><div class="line">上面把命令数据封装成binder_transaction_data，然后</div><div class="line">写到mOut中，mOut是命令的缓冲区，也是一个Parcel</div><div class="line">    mOut.writeInt32(cmd);</div><div class="line">    mOut.write(&amp;tr, sizeof(tr));</div><div class="line">//仅仅写到了Parcel中，Parcel好像没和/dev/binder设备有什么关联啊？</div><div class="line">恩，那只能在另外一个地方写到binder设备中去了。难道是在？</div><div class="line">    return NO_ERROR;</div><div class="line">&#125;</div><div class="line">//说对了，就是在waitForResponse中</div><div class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</div><div class="line">&#123;</div><div class="line">    int32_t cmd;</div><div class="line">    int32_t err;</div><div class="line"> </div><div class="line">while (1) &#123;</div><div class="line">//talkWithDriver，哈哈，应该是这里了</div><div class="line">        if ((err=talkWithDriver()) &lt; NO_ERROR) break;</div><div class="line">        err = mIn.errorCheck();</div><div class="line">        if (err &lt; NO_ERROR) break;</div><div class="line">        if (mIn.dataAvail() == 0) continue;</div><div class="line">        //看见没？这里开始操作mIn了，看来talkWithDriver中</div><div class="line">//把mOut发出去，然后从driver中读到数据放到mIn中了。</div><div class="line">        cmd = mIn.readInt32();</div><div class="line"> </div><div class="line">        switch (cmd) &#123;</div><div class="line">        case BR_TRANSACTION_COMPLETE:</div><div class="line">            if (!reply &amp;&amp; !acquireResult) goto finish;</div><div class="line">            break;</div><div class="line">   .....</div><div class="line">    return err;</div><div class="line">&#125;</div><div class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</div><div class="line">&#123;</div><div class="line">binder_write_read bwr;</div><div class="line">   //中间东西太复杂了，不就是把mOut数据和mIn接收数据的处理后赋值给bwr吗？</div><div class="line">    status_t err;</div><div class="line">    do &#123;</div><div class="line">//用ioctl来读写</div><div class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)</div><div class="line">            err = NO_ERROR;</div><div class="line">        else</div><div class="line">            err = -errno;</div><div class="line">  &#125; while (err == -EINTR);</div><div class="line">//到这里，回复数据就在bwr中了，bmr接收回复数据的buffer就是mIn提供的</div><div class="line">        if (bwr.read_consumed &gt; 0) &#123;</div><div class="line">            mIn.setDataSize(bwr.read_consumed);</div><div class="line">            mIn.setDataPosition(0);</div><div class="line">        &#125;</div><div class="line">return NO_ERROR;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，到这里，我们发送addService的流程就彻底走完了。<br>BpServiceManager发送了一个addService命令到BnServiceManager，然后收到回复。<br>先继续我们的main函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();   </div><div class="line">MediaPlayerService::instantiate();</div><div class="line">---》该函数内部调用addService，把MediaPlayerService信息 add到ServiceManager中</div><div class="line">    ProcessState::self()-&gt;startThreadPool();</div><div class="line">    IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有个容易搞晕的地方：<br>MediaPlayerService是一个BnMediaPlayerService,那么它是不是应该等着<br>BpMediaPlayerService来和他交互呢?但是我们没看见MediaPlayerService有打开binder设备的操作啊！<br>这个嘛，到底是继续addService操作的另一端BnServiceManager还是先说<br>BnMediaPlayerService呢？<br>还是先说BnServiceManager吧。顺便把系统的Binder架构说说。</p>
<h4 id="四、BnServiceManager"><a href="#四、BnServiceManager" class="headerlink" title="四、BnServiceManager"></a>四、BnServiceManager</h4><p>上面说了，defaultServiceManager返回的是一个BpServiceManager，通过它可以把命令请求发送到binder设备，而且handle的值为0。那么，系统的另外一端肯定有个接收命令的，那又是谁呢？<br>很可惜啊，BnServiceManager不存在，但确实有一个程序完成了BnServiceManager的工作，那就是service.exe(如果在windows上一定有exe后缀，叫service的名字太多了，这里加exe就表明它是一个程序)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char **argv)</div><div class="line">&#123;</div><div class="line">    struct binder_state *bs;</div><div class="line">    void *svcmgr = BINDER_SERVICE_MANAGER;</div><div class="line">    bs = binder_open(128*1024);//应该是打开binder设备吧？</div><div class="line">    binder_become_context_manager(bs) //成为manager</div><div class="line">    svcmgr_handle = svcmgr;</div><div class="line">    binder_loop(bs, svcmgr_handler);//处理BpServiceManager发过来的命令</div><div class="line">&#125;</div><div class="line">看看binder_open是不是和我们猜得一样？</div><div class="line">struct binder_state *binder_open(unsigned mapsize)</div><div class="line">&#123;</div><div class="line">    struct binder_state *bs;</div><div class="line">    bs = malloc(sizeof(*bs));</div><div class="line">   ....</div><div class="line">    bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);//果然如此</div><div class="line">  ....</div><div class="line">    bs-&gt;mapsize = mapsize;</div><div class="line">    bs-&gt;mapped = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);</div><div class="line">  &#125;</div><div class="line">再看看binder_become_context_manager</div><div class="line">int binder_become_context_manager(struct binder_state *bs)</div><div class="line">&#123;</div><div class="line">    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);//把自己设为MANAGER</div><div class="line">&#125;</div><div class="line">binder_loop 肯定是从binder设备中读请求，写回复的这么一个循环吧？</div><div class="line">void binder_loop(struct binder_state *bs, binder_handler func)</div><div class="line">&#123;</div><div class="line">    int res;</div><div class="line">    struct binder_write_read bwr;</div><div class="line">    readbuf[0] = BC_ENTER_LOOPER;</div><div class="line">    binder_write(bs, readbuf, sizeof(unsigned));</div><div class="line">    for (;;) &#123;//果然是循环</div><div class="line">        bwr.read_size = sizeof(readbuf);</div><div class="line">        bwr.read_consumed = 0;</div><div class="line">        bwr.read_buffer = (unsigned) readbuf;</div><div class="line"> </div><div class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</div><div class="line">      //哈哈，收到请求了，解析命令</div><div class="line">        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);</div><div class="line">  &#125;</div><div class="line">这个...后面还要说吗？？</div><div class="line">恩，最后有一个类似handleMessage的地方处理各种各样的命令。这个就是</div><div class="line">svcmgr_handler,就在ServiceManager.c中</div><div class="line">int svcmgr_handler(struct binder_state *bs,</div><div class="line">                   struct binder_txn *txn,</div><div class="line">                   struct binder_io *msg,</div><div class="line">                   struct binder_io *reply)</div><div class="line">&#123;</div><div class="line">    struct svcinfo *si;</div><div class="line">    uint16_t *s;</div><div class="line">    unsigned len;</div><div class="line">    void *ptr;</div><div class="line"> </div><div class="line">    s = bio_get_string16(msg, &amp;len);</div><div class="line">    switch(txn-&gt;code) &#123;</div><div class="line">    case SVC_MGR_ADD_SERVICE:</div><div class="line">        s = bio_get_string16(msg, &amp;len);</div><div class="line">        ptr = bio_get_ref(msg);</div><div class="line">        if (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid))</div><div class="line">            return -1;</div><div class="line">        break;</div><div class="line">...</div><div class="line">其中，do_add_service真正添加BnMediaService信息</div><div class="line">int do_add_service(struct binder_state *bs,</div><div class="line">                   uint16_t *s, unsigned len,</div><div class="line">                   void *ptr, unsigned uid)</div><div class="line">&#123;</div><div class="line">    struct svcinfo *si;</div><div class="line">    si = find_svc(s, len);s是一个list</div><div class="line">     si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t));</div><div class="line">       si-&gt;ptr = ptr;</div><div class="line">        si-&gt;len = len;</div><div class="line">        memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t));</div><div class="line">        si-&gt;name[len] = &apos;\0&apos;;</div><div class="line">        si-&gt;death.func = svcinfo_death;</div><div class="line">        si-&gt;death.ptr = si;</div><div class="line">        si-&gt;next = svclist;</div><div class="line">        svclist = si; //看见没，这个svclist是一个列表，保存了当前注册到ServiceManager</div><div class="line">中的信息</div><div class="line">    &#125;</div><div class="line">   binder_acquire(bs, ptr);//这个吗。当这个Service退出后，我希望系统通知我一下，好释放上面malloc出来的资源。大概就是干这个事情的。</div><div class="line">    binder_link_to_death(bs, ptr, &amp;si-&gt;death);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>喔，对于addService来说，看来ServiceManager把信息加入到自己维护的一个服务列表中了。</p>
<h4 id="五ServiceManager存在的意义"><a href="#五ServiceManager存在的意义" class="headerlink" title="五ServiceManager存在的意义"></a>五ServiceManager存在的意义</h4><p>为何需要一个这样的东西呢？<br>原来，Android系统中Service信息都是先add到ServiceManager中，由ServiceManager来集中管理，这样就可以查询当前系统有哪些服务。而且,Android系统中某个服务例如MediaPlayerService的客户端想要和MediaPlayerService通讯的话，必须先向ServiceManager查询MediaPlayerService的信息，然后通过ServiceManager返回的东西再来和MediaPlayerService交互。<br>毕竟，要是MediaPlayerService身体不好，老是挂掉的话，客户的代码就麻烦了，就不知道后续新生的MediaPlayerService的信息了，所以只能这样：</p>
<ol>
<li>MediaPlayerService向SM注册<br>l. MediaPlayerClient查询当前注册在SM中的MediaPlayerService的信息<br>l. 根据这个信息，MediaPlayerClient和MediaPlayerService交互<br>另外，ServiceManager的handle标示是0，所以只要往handle是0的服务发送消息了，最终都会被传递到ServiceManager中去。<br>MediaService的运行：<br>ldefaultServiceManager得到了BpServiceManager，然后MediaPlayerService 实例化后，调用BpServiceManager的addService函数<br>l. 这个过程中，是service_manager收到addService的请求，然后把对应信息放到自己保存的一个服务list中<br>到这儿，我们可看到，service_manager有一个binder_looper函数，专门等着从binder中接收请求。虽然service_manager没有从BnServiceManager中派生，但是它肯定完成了BnServiceManager的功能。<br>同样，我们创建了MediaPlayerService即BnMediaPlayerService，那它也应该：<br>l. 打开binder设备<br>l. 也搞一个looper循环，然后坐等请求<br>service，service，这个和网络编程中的监听socket的工作很像嘛！<br>好吧，既然MediaPlayerService的构造函数没有看到显示的打开binder设备，那么我们看看它的父类即BnXXX又到底干了些什么呢？</li>
</ol>
<h4 id="六-MediaPlayerService打开binder"><a href="#六-MediaPlayerService打开binder" class="headerlink" title="六 MediaPlayerService打开binder"></a>六 MediaPlayerService打开binder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class MediaPlayerService : public BnMediaPlayerService</div><div class="line">// MediaPlayerService从BnMediaPlayerService派生</div><div class="line">//而BnMediaPlayerService从BnInterface和IMediaPlayerService同时派生</div><div class="line">class BnMediaPlayerService: public BnInterface&lt;IMediaPlayerService&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    virtual status_t    onTransact( uint32_t code,</div><div class="line">                                    const Parcel&amp; data,</div><div class="line">                                    Parcel* reply,</div><div class="line">                                    uint32_t flags = 0);</div><div class="line">&#125;;</div><div class="line">看起来，BnInterface似乎更加和打开设备相关啊。</div><div class="line">template&lt;typename INTERFACE&gt;</div><div class="line">class BnInterface : public INTERFACE, public BBinder</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    virtual sp&lt;IInterface&gt;      queryLocalInterface(const String16&amp; _descriptor);</div><div class="line">    virtual const String16&amp;     getInterfaceDescriptor() const;</div><div class="line"> </div><div class="line">protected:</div><div class="line">    virtual IBinder*            onAsBinder();</div><div class="line">&#125;;</div><div class="line">兑现后变成</div><div class="line">class BnInterface : public IMediaPlayerService, public BBinder</div><div class="line">BBinder?BpBinder？是不是和BnXXX以及BpXXX对应的呢？如果是，为什么又叫BBinder呢？</div><div class="line">BBinder::BBinder()</div><div class="line">    : mExtras(NULL)</div><div class="line">&#123;</div><div class="line">//没有打开设备的地方啊？</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回想下，我们的Main_MediaService程序，有哪里打开过binder吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char** argv)</div><div class="line">&#123;</div><div class="line">//对啊，我在ProcessState中不是打开过binder了吗？</div><div class="line"> </div><div class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</div><div class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">MediaPlayerService::instantiate();   </div><div class="line">  ......</div></pre></td></tr></table></figure></p>
<h4 id="七、looper"><a href="#七、looper" class="headerlink" title="七、looper"></a>七、looper</h4><p>原来打开binder设备的地方是和进程相关的啊？一个进程打开一个就可以了。那么，我在哪里进行类似的消息循环looper操作呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">//难道是下面两个？</div><div class="line">ProcessState::self()-&gt;startThreadPool();</div><div class="line">IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">看看startThreadPool吧</div><div class="line">void ProcessState::startThreadPool()</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">    spawnPooledThread(true);</div><div class="line">&#125;</div><div class="line">void ProcessState::spawnPooledThread(bool isMain)</div><div class="line">&#123;</div><div class="line">    sp&lt;Thread&gt; t = new PoolThread(isMain);isMain是TRUE</div><div class="line">//创建线程池，然后run起来，和java的Thread何其像也。</div><div class="line">    t-&gt;run(buf);</div><div class="line"> &#125;</div><div class="line">PoolThread从Thread类中派生，那么此时会产生一个线程吗？看看PoolThread和Thread的构造吧</div><div class="line">PoolThread::PoolThread(bool isMain)</div><div class="line">        : mIsMain(isMain)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">Thread::Thread(bool canCallJava)//canCallJava默认值是true</div><div class="line">    :   mCanCallJava(canCallJava),</div><div class="line">        mThread(thread_id_t(-1)),</div><div class="line">        mLock(&quot;Thread::mLock&quot;),</div><div class="line">        mStatus(NO_ERROR),</div><div class="line">        mExitPending(false), mRunning(false)</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line">喔，这个时候还没有创建线程呢。然后调用PoolThread::run，实际调用了基类的run。</div><div class="line">status_t Thread::run(const char* name, int32_t priority, size_t stack)</div><div class="line">&#123;</div><div class="line">  bool res;</div><div class="line">    if (mCanCallJava) &#123;</div><div class="line">        res = createThreadEtc(_threadLoop,//线程函数是_threadLoop</div><div class="line">                this, name, priority, stack, &amp;mThread);</div><div class="line">    &#125;</div><div class="line">//终于，在run函数中，创建线程了。从此</div><div class="line">主线程执行</div><div class="line">IPCThreadState::self()-&gt;joinThreadPool();</div><div class="line">新开的线程执行_threadLoop</div><div class="line">我们先看看_threadLoop</div><div class="line">int Thread::_threadLoop(void* user)</div><div class="line">&#123;</div><div class="line">    Thread* const self = static_cast&lt;Thread*&gt;(user);</div><div class="line">    sp&lt;Thread&gt; strong(self-&gt;mHoldSelf);</div><div class="line">    wp&lt;Thread&gt; weak(strong);</div><div class="line">    self-&gt;mHoldSelf.clear();</div><div class="line"> </div><div class="line">    do &#123;</div><div class="line"> ...</div><div class="line">        if (result &amp;&amp; !self-&gt;mExitPending) &#123;</div><div class="line">                result = self-&gt;threadLoop();哇塞，调用自己的threadLoop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">我们是PoolThread对象，所以调用PoolThread的threadLoop函数</div><div class="line">virtual bool PoolThread ::threadLoop()</div><div class="line">    &#123;</div><div class="line">//mIsMain为true。</div><div class="line">//而且注意，这是一个新的线程，所以必然会创建一个</div><div class="line">新的IPCThreadState对象（记得线程本地存储吗？TLS），然后      </div><div class="line">IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">主线程和工作线程都调用了joinThreadPool，看看这个干嘛了！</div><div class="line">void IPCThreadState::joinThreadPool(bool isMain)</div><div class="line">&#123;</div><div class="line">     mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</div><div class="line">     status_t result;</div><div class="line">    do &#123;</div><div class="line">        int32_t cmd;</div><div class="line">         result = talkWithDriver();</div><div class="line">         result = executeCommand(cmd);</div><div class="line">        &#125;</div><div class="line">       &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</div><div class="line"> </div><div class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</div><div class="line">    talkWithDriver(false);</div><div class="line">&#125;</div><div class="line">看到没？有loop了，但是好像是有两个线程都执行了这个啊！这里有两个消息循环？</div><div class="line">下面看看executeCommand</div><div class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</div><div class="line">&#123;</div><div class="line">BBinder* obj;</div><div class="line">    RefBase::weakref_type* refs;</div><div class="line">    status_t result = NO_ERROR;</div><div class="line">case BR_TRANSACTION:</div><div class="line">        &#123;</div><div class="line">            binder_transaction_data tr;</div><div class="line">            result = mIn.read(&amp;tr, sizeof(tr));</div><div class="line">//来了一个命令，解析成BR_TRANSACTION,然后读取后续的信息</div><div class="line">       Parcel reply;</div><div class="line">             if (tr.target.ptr) &#123;</div><div class="line">//这里用的是BBinder。</div><div class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</div><div class="line">                const status_t error = b-&gt;transact(tr.code, buffer, &amp;reply, 0);</div><div class="line">&#125;</div><div class="line">让我们看看BBinder的transact函数干嘛了</div><div class="line">status_t BBinder::transact(</div><div class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</div><div class="line">&#123;</div><div class="line">就是调用自己的onTransact函数嘛      </div><div class="line">err = onTransact(code, data, reply, flags);</div><div class="line">    return err;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BnMediaPlayerService从BBinder派生，所以会调用到它的onTransact函数<br>终于水落石出了，让我们看看BnMediaPlayerServcice的onTransact函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">status_t BnMediaPlayerService::onTransact(</div><div class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</div><div class="line">&#123;</div><div class="line">// BnMediaPlayerService从BBinder和IMediaPlayerService派生，所有IMediaPlayerService</div><div class="line">//看到下面的switch没？所有IMediaPlayerService提供的函数都通过命令类型来区分</div><div class="line">//</div><div class="line">    switch(code) &#123;</div><div class="line">        case CREATE_URL: &#123;</div><div class="line">            CHECK_INTERFACE(IMediaPlayerService, data, reply);</div><div class="line">            // create是一个虚函数，由MediaPlayerService来实现！！</div><div class="line">            sp&lt;IMediaPlayer&gt; player = create(</div><div class="line">                    pid, client, url, numHeaders &gt; 0 ? &amp;headers : NULL);</div><div class="line"> </div><div class="line">            reply-&gt;writeStrongBinder(player-&gt;asBinder());</div><div class="line">            return NO_ERROR;</div><div class="line">        &#125; break;</div></pre></td></tr></table></figure></p>
<p>其实，到这里，我们就明白了。BnXXX的onTransact函数收取命令，然后派发到派生类的函数，由他们完成实际的工作。<br>说明：<br>这里有点特殊，startThreadPool和joinThreadPool完后确实有两个线程，主线程和工作线程，而且都在做消息循环。为什么要这么做呢？他们参数isMain都是true。不知道google搞什么。难道是怕一个线程工作量太多，所以搞两个线程来工作？这种解释应该也是合理的。<br>网上有人测试过把最后一句屏蔽掉，也能正常工作。但是难道主线程提出了，程序还能不退出吗？这个…管它的，反正知道有两个线程在那处理就行了。</p>
<p>四 MediaPlayerClient<br>这节讲讲MediaPlayerClient怎么和MediaPlayerService交互。<br>使用MediaPlayerService的时候，先要创建它的BpMediaPlayerService。我们看看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">IMediaDeathNotifier::getMediaPlayerService()</div><div class="line">&#123;</div><div class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</div><div class="line">        sp&lt;IBinder&gt; binder;</div><div class="line">        do &#123;</div><div class="line">//向SM查询对应服务的信息，返回binder           </div><div class="line">binder = sm-&gt;getService(String16(&quot;media.player&quot;));</div><div class="line">            if (binder != 0) &#123;</div><div class="line">                break;</div><div class="line">             &#125;</div><div class="line">             usleep(500000); // 0.5 s</div><div class="line">        &#125; while(true);</div><div class="line"> </div><div class="line">//通过interface_cast，将这个binder转化成BpMediaPlayerService</div><div class="line">//注意，这个binder只是用来和binder设备通讯用的，实际</div><div class="line">//上和IMediaPlayerService的功能一点关系都没有。</div><div class="line">//还记得我说的Bridge模式吗?BpMediaPlayerService用这个binder和BnMediaPlayerService</div><div class="line">//通讯。</div><div class="line">    sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</div><div class="line">    &#125;</div><div class="line">    return sMediaPlayerService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么反复强调这个Bridge？其实也不一定是Bridge模式，但是我真正想说明的是：<br>Binder其实就是一个和binder设备打交道的接口，而上层IMediaPlayerService只不过把它当做一个类似socket使用罢了。我以前经常把binder和上层类IMediaPlayerService的功能混到一起去。<br>当然，你们不一定会犯这个错误。但是有一点请注意：<br>下班》</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Author By <a target="_blank" href="https://github.com/jianjin33">简祖明.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

